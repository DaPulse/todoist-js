{"version":3,"sources":["../todoist/Api.js"],"names":["require","API","api_endpoint","session","Session","token","queue","temp_ids","projects","ProjectsManager","project_notes","ProjectNotesManager","items","ItemsManager","labels","LabelsManager","filters","FiltersManager","notes","NotesManager","live_notifications","LiveNotificationsManager","reminders","RemindersManager","locations","LocationsManager","invitations","InvitationsManager","biz_invitations","BizInvitationsManager","user","UserManager","collaborators","CollaboratorsManager","collaborator_states","CollaboratorStatesManager","completed","CompletedManager","uploads","UploadsManager","activity","ActivityManager","business_users","BusinessUsersManager","templates","TemplatesManager","backups","BackupsManager","state","day_orders","day_orders_timestamp","live_notifications_last_read_id","settings_notifications","get","get_api_url","resource","params","post","headers","include_notification_settings","resource_types","JSON","stringify","commands","Object","keys","response","temp_id_mapping","length","temp_keys","forEach","temp_id","new_id","replace_temp_id","update_state","console","warning","queries","map","syncdata","key","collaborator","Collaborator","CollaboratorState","Filter","Item","Label","LiveNotification","Note","ProjectNote","Project","Reminder","resp_models_mapping","datatype","Promise","resolve","then","find_object","remoteObj","localObj","assign","data","push","newobj","promises","typePromises","all","filter","is_deleted","get_by_id","obj","id","get_by_ids","project_id","user_id","type","objIndex","content","sync","sync_status","raise_on_error","Error"],"mappings":"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","file":"Api.js","sourcesContent":["/**\n * @fileoverview Implements the API that makes it possible to interact with a Todoist user\n *   account and its data.\n * @author Cosmitar (JS Version)\n */\nimport Session from \"./Session\";\n// managers\nimport ActivityManager from \"./managers/ActivityManager\";\nimport BackupsManager from \"./managers/BackupsManager\";\nimport BizInvitationsManager from \"./managers/BizInvitationsManager\";\nimport BusinessUsersManager from \"./managers/BusinessUsersManager\";\nimport CollaboratorsManager from \"./managers/CollaboratorsManager\";\nimport CollaboratorStatesManager from \"./managers/CollaboratorStatesManager\";\nimport CompletedManager from \"./managers/CompletedManager\";\nimport FiltersManager from \"./managers/FiltersManager\";\nimport InvitationsManager from \"./managers/InvitationsManager\";\nimport ItemsManager from \"./managers/ItemsManager\";\nimport LabelsManager from \"./managers/LabelsManager\";\nimport LiveNotificationsManager from \"./managers/LiveNotificationsManager\";\nimport LocationsManager from \"./managers/LocationsManager\";\nimport NotesManager from \"./managers/NotesManager\";\nimport ProjectNotesManager from \"./managers/ProjectNotesManager\";\nimport ProjectsManager from \"./managers/ProjectsManager\";\nimport RemindersManager from \"./managers/RemindersManager\";\nimport TemplatesManager from \"./managers/TemplatesManager\";\nimport UploadsManager from \"./managers/UploadsManager\";\nimport UserManager from \"./managers/UserManager\";\n// models\nimport Collaborator from \"./models/Collaborator\";\nimport CollaboratorState from \"./models/CollaboratorState\";\nimport Filter from \"./models/Filter\";\nimport Item from \"./models/Item\";\nimport Label from \"./models/Label\";\nimport LiveNotification from \"./models/LiveNotification\";\nimport Note from \"./models/Note\";\nimport Project from \"./models/Project\";\nimport ProjectNote from \"./models/ProjectNote\";\nimport Reminder from \"./models/Reminder\";\n\nimport { generate_uuid } from \"./utils/uuid\";\n\nrequire(\"babel-polyfill\");\n/**\n * @class Session\n */\nclass API {\n  constructor(token) {\n    this.api_endpoint = \"https://todoist.com\";\n    // Session instance for requests\n    this.session = new Session({ token });\n    // Requests to be sent are appended here\n    this.queue = [];\n    // Mapping of temporary ids to real ids\n    this.temp_ids = {};\n\n    // managers\n    this.projects = new ProjectsManager(this);\n    this.project_notes = new ProjectNotesManager(this);\n    this.items = new ItemsManager(this);\n    this.labels = new LabelsManager(this);\n    this.filters = new FiltersManager(this);\n    this.notes = new NotesManager(this);\n    this.live_notifications = new LiveNotificationsManager(this);\n    this.reminders = new RemindersManager(this);\n    this.locations = new LocationsManager(this);\n    this.invitations = new InvitationsManager(this);\n    this.biz_invitations = new BizInvitationsManager(this);\n    this.user = new UserManager(this);\n    this.collaborators = new CollaboratorsManager(this);\n    this.collaborator_states = new CollaboratorStatesManager(this);\n    this.completed = new CompletedManager(this);\n    this.uploads = new UploadsManager(this);\n    this.activity = new ActivityManager(this);\n    this.business_users = new BusinessUsersManager(this);\n    this.templates = new TemplatesManager(this);\n    this.backups = new BackupsManager(this);\n    // Local copy of all of the user's objects\n    this.state = {\n      collaborator_states: [],\n      collaborators: [],\n      day_orders: {},\n      day_orders_timestamp: \"\",\n      filters: [],\n      items: [],\n      labels: [],\n      live_notifications: [],\n      live_notifications_last_read_id: -1,\n      locations: [],\n      notes: [],\n      project_notes: [],\n      projects: [],\n      reminders: [],\n      settings_notifications: {},\n      user: {}\n    };\n  }\n\n  /**\n   * Performs a GET request prepending the API endpoint.\n   * @param {string} resource Requested resource\n   * @param {Object} params\n   * @return {Promise}\n   */\n  get(resource, params) {\n    return this.session.get(this.get_api_url(resource), params);\n  }\n\n  /**\n   * Performs a POST request prepending the API endpoint.\n   * @param {string} resource Requested resource\n   * @param {Object} params\n   * @return {Promise}\n   */\n  post(resource, params, headers) {\n    return this.session.post(this.get_api_url(resource), params, headers);\n  }\n\n  /**\n   * Sends to the server the changes that were made locally, and also\n   *   fetches the latest updated data from the server.\n   * @param {Array.<object>} commands List of commands to be processed.\n   * @param {Object} params\n   * @return {Object} Server response\n   */\n  async sync(commands = []) {\n    const response = await this.session.get(this.get_api_url(\"sync\"), {\n      day_orders_timestamp: this.state.day_orders_timestamp,\n      include_notification_settings: 1,\n      resource_types: JSON.stringify([\"all\"]),\n      commands: JSON.stringify(commands)\n    });\n\n    const temp_keys = Object.keys(response.temp_id_mapping || {});\n    if (temp_keys.length > 0) {\n      temp_keys.forEach(temp_id => {\n        const new_id = response.temp_id_mapping[temp_id];\n        this.temp_ids[temp_id] = new_id;\n        this.replace_temp_id(temp_id, new_id);\n      });\n    }\n    await this.update_state(response);\n\n    return response;\n  }\n\n  /**\n   * Performs a server query\n   * @deprecated\n   * @param {Array.<Object>} params List of parameters to query\n   * @return {Promise}\n   */\n  query(params = []) {\n    console.warning(\n      'You are using a deprecated method \"query\". Unexpected behaviors might occur. See: https://github.com/Doist/todoist-api/issues/22'\n    );\n    return this.session.get(this.get_api_url(\"query\"), {\n      queries: JSON.stringify(params)\n    });\n  }\n\n  /**\n   * Updates the local state, with the data returned by the server after a\n   *   sync.\n   * @param {Object} syncdata Data returned by {@code this.sync}.\n   */\n  async update_state(syncdata) {\n    // It is straightforward to update these type of data, since it is\n    // enough to just see if they are present in the sync data, and then\n    // either replace the local values or update them.\n    const keys = [\n      \"day_orders\",\n      \"day_orders_timestamp\",\n      \"live_notifications_last_read_id\",\n      \"locations\",\n      \"settings_notifications\",\n      \"user\"\n    ];\n    keys.map(key => {\n      if (syncdata[key]) {\n        this.state[key] = syncdata[key];\n      }\n    });\n\n    const resp_models_mapping = {\n      collaborator: Collaborator,\n      collaborator_states: CollaboratorState,\n      filters: Filter,\n      items: Item,\n      labels: Label,\n      live_notifications: LiveNotification,\n      notes: Note,\n      project_notes: ProjectNote,\n      projects: Project,\n      reminders: Reminder\n    };\n\n    // Updating these type of data is a bit more complicated, since it is\n    // necessary to find out whether an object in the sync data is new,\n    // updates an existing object, or marks an object to be deleted.  But\n    // the same procedure takes place for each of these types of data.\n    let promises = [];\n    Object.keys(resp_models_mapping).forEach(datatype => {\n      // Process each object of this specific type in the sync data.\n      // Collect a promise for each object due to some this.find_object are asynchronous\n      // since they hit the server looking for remote objects\n      const typePromises = (syncdata[datatype] || []).map(remoteObj => {\n        return Promise.resolve().then(async () => {\n          // Find out whether the object already exists in the local state.\n          const localObj = await this.find_object(datatype, remoteObj);\n          if (localObj) {\n            // If the object is already present in the local state, then\n            // we either update it\n            Object.assign(localObj.data, remoteObj);\n          } else {\n            // If not, then the object is new and it should be added\n            const newobj = new resp_models_mapping[datatype](remoteObj, this);\n            this.state[datatype].push(newobj);\n          }\n        });\n      });\n\n      promises = [...promises, ...typePromises];\n    });\n    // await for all promises to resolve and continue.\n    await Promise.all(promises);\n\n    // since sync response isn't including deleted objects, we'll rid of from state\n    // all those items marked as to be deleted\n    Object.keys(resp_models_mapping).forEach(datatype => {\n      if (this.state[datatype]) {\n        this.state[datatype] = this.state[datatype].filter(\n          stateObj => stateObj.is_deleted !== 1\n        );\n      }\n    });\n  }\n\n  /**\n   * Searches for an object in the local state, depending on the type of object, and then on its primary key is.\n   *   If the object is found it is returned, and if not, then null is returned.\n   * @param {string} objtype Name for the type of the searching object.\n   * @param {Object} obj Object from where to take search paramters.\n   * @return {Object|null} Depending on search result.\n   */\n  find_object(objtype, obj) {\n    if (objtype === \"collaborators\") {\n      return this.collaborators.get_by_id(obj.id);\n    } else if (objtype === \"collaborator_states\") {\n      return this.collaborator_states.get_by_ids(obj.project_id, obj.user_id);\n    } else if (objtype === \"filters\") {\n      return this.filters.get_by_id(obj.id, true);\n    } else if (objtype === \"items\") {\n      return this.items.get_by_id(obj.id, true);\n    } else if (objtype === \"labels\") {\n      return this.labels.get_by_id(obj.id, true);\n    } else if (objtype === \"live_notifications\") {\n      return this.live_notifications.get_by_id(obj.id);\n    } else if (objtype === \"notes\") {\n      return this.notes.get_by_id(obj.id, true);\n    } else if (objtype === \"project_notes\") {\n      return this.project_notes.get_by_id(obj.id, true);\n    } else if (objtype === \"projects\") {\n      return this.projects.get_by_id(obj.id, true);\n    } else if (objtype === \"reminders\") {\n      return this.reminders.get_by_id(obj.id, true);\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Replaces the temporary id generated locally when an object was first\n   *   created, with a real Id supplied by the server. True is returned if\n   *   the temporary id was found and replaced, and false otherwise.\n   * @param {string} temp_id Temporary item id.\n   * @param {number} new_id New item id.\n   * @return {boolean} Whether temporary id was found or not.\n   */\n  replace_temp_id(temp_id, new_id) {\n    const datatypes = [\n      \"filters\",\n      \"items\",\n      \"labels\",\n      \"notes\",\n      \"project_notes\",\n      \"projects\",\n      \"reminders\"\n    ];\n    datatypes.forEach(type => {\n      this.state[type].forEach((obj, objIndex) => {\n        if (obj.temp_id === temp_id) {\n          this.state[type][objIndex].id = new_id;\n        }\n      });\n    });\n  }\n\n  /**\n   * Generates a uuid.\n   * @return {string}\n   */\n  generate_uuid() {\n    return generate_uuid();\n  }\n\n  /**\n   * Returns the full API url to hit.\n   * @param {string} resource The API resource.\n   * @return {string}\n   */\n  get_api_url(resource = \"\") {\n    return `${this.api_endpoint}/API/v8/${resource}`;\n  }\n\n  /**\n   * Adds a new task.\n   * @param {string} content The description of the task.\n   * @param {Object} params All other paramters to set in the new task.\n   * @return {Promise}\n   */\n  add_item(content, params = {}) {\n    Object.assign(params, { content });\n    if (params.labels) {\n      params.labels = JSON.stringify(params.labels);\n    }\n    return this.get(\"add_item\", params);\n  }\n\n  /**\n   * Commits all requests that are queued.  Note that, without calling this\n   * method none of the changes that are made to the objects are actually\n   * synchronized to the server, unless one of the aforementioned Sync API\n   * calls are called directly.\n   */\n  async commit(raise_on_error = true) {\n    if (!this.queue.length) return;\n\n    const response = await this.sync(this.queue);\n    this.queue = [];\n    if (response.sync_status) {\n      if (raise_on_error) {\n        Object.keys(response.sync_status).forEach(key => {\n          if (response.sync_status[key] != \"ok\") {\n            throw new Error(\n              `sync fail (${key}, ${JSON.stringify(response.sync_status[key])})`\n            );\n          }\n        });\n      }\n    }\n    return response;\n  }\n}\n\nexport default API;\n"]}